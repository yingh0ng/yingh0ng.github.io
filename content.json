{"meta":{"title":"JOY ZHANG","subtitle":"呼哇","description":"java","author":"JOY ZHANG","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-11T10:53:50.000Z","updated":"2018-06-11T10:54:35.914Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-11T10:52:45.000Z","updated":"2018-06-11T10:53:34.252Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql联表执行过程","slug":"mysql联表执行过程","date":"2018-06-15T02:48:04.000Z","updated":"2018-06-22T09:07:50.332Z","comments":true,"path":"2018/06/15/mysql联表执行过程/","link":"","permalink":"http://yoursite.com/2018/06/15/mysql联表执行过程/","excerpt":"","text":"单个表的联表当用join关联另外一个表的时候，mysql默认选择以小表作为驱动表。而left join强制用左表作为驱动表，right join则强制用右表作为驱动表。 建表语句：CREATE TABLE student ( id bigint(3) NOT NULL AUTO_INCREMENT, name varchar(15) NOT NULL, class_id bigint(3) NOT NULL, PRIMARY KEY (id), KEY idx_class_id (class_id)); CREATE TABLE class ( id bigint(3) NOT NULL AUTO_INCREMENT, name varchar(15) NOT NULL, PRIMARY KEY (id)); EXPLAIN SELECT FROM student s JOIN class c ON c.id=s.class_id;EXPLAIN SELECT FROM student s LEFT JOIN class c ON c.id=s.class_id; 结果1| id | select_type | table | type | possible_keys | key | key_len | ref | rows | filtered || — | ———– | —– | —- | ————- | ———— | ——- | ———- | —- | ——– || 1 | SIMPLE | c | ALL | PRIMARY | ———— | ——- | ———- | 29 | 100 || 1 | SIMPLE | s | ref | idx_class_id- | idx_class_id | 8 | test2.c.id | 1 | 100 | 结果2| id | select_type | table | type | possible_keys | key | key_len | ref | rows | filtered || — | ———– | —– | —— | ————- | ——- | ——- | —————- | —- | ——– || 1 | SIMPLE | s | ALL | PRIMARY | — | ——- | —————- | 55 | 100 || 1 | SIMPLE | c | eq_ref | PRIMARY | PRIMARY | 8 | test2.s.class_id | 1 | 100 | 注意：当表的数据太少或者索引列存在大量相等值时，mysql不走索引。准确的说，当扫描索引列等于某值的开销加上扫描索引数的开销大于扫描全表的开销时，mysql会不走索引 多个表的联表用驱动表关联第一个表的结果集去关联第二个表，以此类推。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[]},{"title":"部署hexo过程中遇到的问题","slug":"problem-hexo","date":"2018-06-10T16:00:00.000Z","updated":"2018-06-13T03:22:41.258Z","comments":true,"path":"2018/06/11/problem-hexo/","link":"","permalink":"http://yoursite.com/2018/06/11/problem-hexo/","excerpt":"1.GPG加密失败在github上配置好ssh key后使用命令hexo deploy后出现一下错误：gpg: skipped “xxx &#120;&#x78;&#x78;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#111;&#x6d;“: secret key not availablegpg: signing failed: secret key not availableerror: gpg failed to sign the datafatal: failed to write commit object","text":"1.GPG加密失败在github上配置好ssh key后使用命令hexo deploy后出现一下错误：gpg: skipped “xxx &#120;&#x78;&#x78;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#111;&#x6d;“: secret key not availablegpg: signing failed: secret key not availableerror: gpg failed to sign the datafatal: failed to write commit object 进入目录C:\\Users\\Administrator.gnupg后发现pubring.gpg和secring.gpg这两个文件大小均为0kb。可能是我之前配置过gpg加密，然后现在过期了。 使用命令：1$ gpg --gen-key 然后会依次让你选择key类型、key文件大小、有效时间，最后填写名称、邮件地址和备注（这三个信息跟github账号无关）。最后输出的信息即为你的gpg密钥，如：pub 2048G/FB7D735A 2018-06-11 [expires: 2020-06-10] Key fingerprint = 401B EC71 97B4 AEE4 089E C017 7AE8 6157 FB7D 736Auid XXX (XX) &#x58;&#88;&#88;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;sub 2048G/A6CA85D3 2018-06-11 [expires: 2020-06-10] 其中pub为公钥，FB7D735A为公钥key，sub为私钥，A6CA85D3为私钥key。 使用命令：1$ gpg --armor --export yourkey “yourkey”为公钥key或者私钥key。打开github-&gt;settings-&gt;SSH and GPG KEYS，添加GPG KEY。把刚才命令输出的信息复制粘贴到这儿。 最后输入：12$ git config --global commit.gpgsign.true$ git config --global user.signingkey FB7D736A（你自己的key） 完成配置。 输入命令：1$ gpg --list-secret-keys 能看到你配置好的GPG key。 使用123$ hexo clean$ hexo Generate$ hexo deploy 重新部署就行。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[]}]}